'use strict';

import AWS from 'aws-sdk-mock';
import nock from 'nock';
import mochaPlugin from 'serverless-mocha-plugin';

// Generated by serverless-mocha-plugin
const mod = require('../updateLocation');
const lambdaWrapper = mochaPlugin.lambdaWrapper;
const expect = mochaPlugin.chai.expect;
const wrapped = lambdaWrapper.wrap(mod, { handler: 'handler' });

// dummy data
const DUMMY = {
  // a payload that will pass validation
  valid: {
    username: process.env.UPDATE_USER,
    location: '44.9741;-93.5066'
  },
  // json from a successful geonames response
  geonamesResponse: {
    "geonames": [
      {
        "adminCode1": "MN",
        "lng": "-93.50662",
        "distance": "0.00375",
        "geonameId": 5052132,
        "toponymName": "Wayzata",
        "countryId": "6252001",
        "fcl": "P",
        "population": 3688,
        "countryCode": "US",
        "name": "Wayzata",
        "fclName": "city, village,...",
        "countryName": "United States",
        "fcodeName": "populated place",
        "adminName1": "Minnesota",
        "lat": "44.97413",
        "fcode": "PPL"
      }
    ]
  }
};

// tests for updateLocation
describe('updateLocation', () => {

  before('set IS_TEST environment variable', done => {
    process.env.IS_TEST = true;
    done();
  });

  describe('input validation', () => {
    it('should return 400 when parameters are empty', () =>
      wrapped.run({
        queryStringParameters: {}
      }).then(res => expect(res.statusCode).to.be.equal(400))
    );
    it('should return 400 when parameters are invalid', () =>
      Promise.all([{
        hello: 'world'
      }, {
        location: ''
      }, {
        username: ''
      }].map(payload => wrapped.run({
        queryStringParameters: payload
      }).then(res => expect(res.statusCode).to.be.equal(400))))
    );
    it('should return 403 when username is invalid', () =>
      Promise.all([{
        username: ''
      }, {
        username: 'null'
      }, {
        username: 'kelvin'
      }, {
        username: '12345'
      }].map(payload => Object.assign(payload, { location: '' }))
        .map(payload => wrapped.run({
          queryStringParameters: payload
        }).then(res => expect(res.statusCode).to.be.equal(403))))
    );
    it('should return 400 when location coordinates are invalid', () =>
      Promise.all([{
        location: ''
      }, {
        location: 'null'
      }, {
        location: 'twenty'
      }, {
        location: 'one-hundred;'
      }, {
        location: 'forty-five;ninety-three-point-five'
      }].map(payload => Object.assign(payload, {
        username: process.env.UPDATE_USER
      }))
        .map(payload => wrapped.run({
          queryStringParameters: payload
        }).then(res => expect(res.statusCode).to.be.equal(400))))
    );
    it('should return 400 when location is not a coordinate', () =>
      Promise.all([{
        location: '20'
      }, {
        location: '100;'
      }, {
        location: '45;93.5;'
      }, {
        location: '45;93.5;0'
      }].map(payload => Object.assign(payload, {
        username: process.env.UPDATE_USER
      }))
        .map(payload => wrapped.run({
          queryStringParameters: payload
        }).then(res => expect(res.statusCode).to.be.equal(400))))
    );
  });

  describe('geonames request', () => {
    let geonames;
    beforeEach('mock geonames requests', done => {
      geonames = nock('http://api.geonames.org')
        .get('/findNearbyPlaceNameJSON')
        .query(true);
      done();
    });
    it('should return 500 when geonames fails', () => {
      geonames.reply(403, {});
      return wrapped.run({
        queryStringParameters: DUMMY.valid
      }).then(res => expect(res.statusCode).to.be.equal(500));
    });
    it('should return 500 when geonames returns no data', () => {
      geonames.reply(200, { geonames: [] });
      return wrapped.run({
        queryStringParameters: DUMMY.valid
      }).then(res => expect(res.statusCode).to.be.equal(500));
    });
  });

  describe('dynamodb put', () => {
    beforeEach('mock geonames requests', done => {
      nock('http://api.geonames.org')
        .get('/findNearbyPlaceNameJSON')
        .query(true)
        .reply(200, DUMMY.geonamesResponse);
      done();
    });
    afterEach('remove aws mocks', done => {
      AWS.restore('DynamoDB.DocumentClient');
      done();
    });
    it('should return 500 when put fails', () => {
      AWS.mock('DynamoDB.DocumentClient', 'put', (_, cb) => cb(new Error()));
      return wrapped.run({
        queryStringParameters: DUMMY.valid
      }).then(res => expect(res.statusCode).to.be.equal(500));
    });
    it('should return 200 when put succeeds', () => {
      AWS.mock('DynamoDB.DocumentClient', 'put', (_, cb) => cb());
      return wrapped.run({
        queryStringParameters: DUMMY.valid
      }).then(res => {
        expect(res.statusCode).to.be.equal(200);
        expect(res.body).to.be.equal(JSON.stringify('success'));
      });
    });
  });

});
